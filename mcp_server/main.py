# generated by fastapi-codegen:
#   filename:  openapi.yaml
#   timestamp: 2025-06-29T03:42:46+00:00



import argparse
import json
import os
from datetime import datetime
from typing import *
from typing import Optional, Union

from autogen.mcp.mcp_proxy import MCPProxy
from autogen.mcp.mcp_proxy.security import BaseSecurity, HTTPBearer
from fastapi import Query, UploadFile
from pydantic import conint, constr

from models import (
    Account,
    AccountList,
    AccountNumber,
    AccountNumberList,
    AccountStatement,
    AccountStatementList,
    AccountTransfer,
    AccountTransferList,
    AchPrenotification,
    AchPrenotificationList,
    AchTransfer,
    AchTransferList,
    ActionARealTimeDecisionParameters,
    Card,
    CardDetails,
    CardDispute,
    CardDisputeList,
    CardList,
    CardProfile,
    CardProfileList,
    CategoryIn,
    CategoryIn1,
    CategoryIn2,
    CheckDeposit,
    CheckDepositList,
    CheckTransfer,
    CheckTransferList,
    CreateACardDisputeParameters,
    CreateACardParameters,
    CreateACardProfileParameters,
    CreateACheckDepositParameters,
    CreateACheckTransferParameters,
    CreateALimitParameters,
    CreateAnAccountNumberParameters,
    CreateAnAccountParameters,
    CreateAnAccountTransferParameters,
    CreateAnAchPrenotificationParameters,
    CreateAnAchReturnParameters,
    CreateAnAchTransferParameters,
    CreateAnEntityParameters,
    CreateAnEventSubscriptionParameters,
    CreateAnExternalAccountParameters,
    CreateASupplementalDocumentForAnEntityParameters,
    CreateAWireDrawdownRequestParameters,
    CreateAWireTransferParameters,
    DeclinedTransaction,
    DeclinedTransactionList,
    DigitalWalletToken1,
    DigitalWalletTokenList,
    Document,
    DocumentList,
    Entity,
    EntityList,
    Error,
    Event,
    EventList,
    EventSubscription,
    EventSubscriptionList,
    ExternalAccount,
    ExternalAccountList,
    File,
    FileList,
    Group,
    InboundAchTransferReturn,
    InboundAchTransferReturnList,
    InboundAchTransferSimulationResult,
    InboundCardAuthorizationSimulationResult,
    InboundDigitalWalletTokenRequestSimulationResult,
    InboundRealTimePaymentsTransferSimulationResult,
    InboundWireDrawdownRequest,
    InboundWireDrawdownRequestList,
    InboundWireTransferSimulationResult,
    Limit,
    LimitList,
    OauthConnection,
    OauthConnectionList,
    PendingTransaction1,
    PendingTransactionList,
    PurposeIn,
    RealTimeDecision,
    ReturnASandboxAchTransferParameters,
    RoutingNumberList,
    SimulateAnAccountStatementBeingCreatedParameters,
    SimulateAnAchTransferToYourAccountParameters,
    SimulateAnAuthorizationOnACardParameters,
    SimulateAnInboundWireDrawdownRequestBeingCreatedParameters,
    SimulateARealTimePaymentsTransferToYourAccountParameters,
    SimulateARefundOnACardParameters,
    SimulateATaxDocumentBeingCreatedParameters,
    SimulateAWireTransferToYourAccountParameters,
    SimulateDigitalWalletProvisioningForACardParameters,
    SimulatesAdvancingTheStateOfACardDisputeParameters,
    SimulateSettlingACardAuthorizationParameters,
    Status42,
    Status44,
    StatusIn,
    StatusIn1,
    StatusIn2,
    StatusIn3,
    Transaction3,
    TransactionList,
    UpdateACardParameters,
    UpdateALimitParameters,
    UpdateAnAccountNumberParameters,
    UpdateAnAccountParameters,
    UpdateAnEventSubscriptionParameters,
    UpdateAnExternalAccountParameters,
    WireDrawdownRequest,
    WireDrawdownRequestList,
    WireTransfer,
    WireTransferList,
)

app = MCPProxy(
    title='Increase API',
    version='0.0.1',
    servers=[
        {'url': 'https://api.increase.com'},
        {'url': 'https://sandbox.increase.com'},
    ],
)


@app.get(
    '/account_numbers',
    tags=['account_management', 'account_statements_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_account_numbers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    status: Optional[Status42] = None,
    account_id: Optional[str] = None,
):
    """
    List Account Numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account_numbers',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_account_number(body: CreateAnAccountNumberParameters):
    """
    Create an Account Number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account_numbers/{account_number_id}',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_account_number(account_number_id: str):
    """
    Retrieve an Account Number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/account_numbers/{account_number_id}',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_an_account_number(
    account_number_id: str, body: UpdateAnAccountNumberParameters = ...
):
    """
    Update an Account Number
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account_statements',
    tags=['account_statements_handling', 'account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_account_statements(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    statement_period_start_after: Optional[datetime] = Query(
        None, alias='statement_period_start.after'
    ),
    statement_period_start_before: Optional[datetime] = Query(
        None, alias='statement_period_start.before'
    ),
    statement_period_start_on_or_after: Optional[datetime] = Query(
        None, alias='statement_period_start.on_or_after'
    ),
    statement_period_start_on_or_before: Optional[datetime] = Query(
        None, alias='statement_period_start.on_or_before'
    ),
):
    """
    List Account Statements
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account_statements/{account_statement_id}',
    tags=['account_management', 'account_statements_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_account_statement(account_statement_id: str):
    """
    Retrieve an Account Statement
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account_transfers',
    tags=['account_transfer_operations', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_account_transfers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Account Transfers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account_transfers',
    tags=['account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_account_transfer(body: CreateAnAccountTransferParameters):
    """
    Create an Account Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/account_transfers/{account_transfer_id}',
    tags=['account_transfer_operations', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_account_transfer(account_transfer_id: str):
    """
    Retrieve an Account Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account_transfers/{account_transfer_id}/approve',
    tags=['account_transfer_operations', 'wire_transfer_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def approve_an_account_transfer(account_transfer_id: str):
    """
    Approve an Account Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/account_transfers/{account_transfer_id}/cancel',
    tags=['account_transfer_operations', 'wire_transfer_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_an_account_transfer(account_transfer_id: str):
    """
    Cancel an Account Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts',
    tags=['account_management', 'entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_accounts(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    entity_id: Optional[str] = None,
    status: Optional[Status44] = None,
):
    """
    List Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_account(body: CreateAnAccountParameters):
    """
    Create an Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/accounts/{account_id}',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_account(account_id: str):
    """
    Retrieve an Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/accounts/{account_id}',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_an_account(account_id: str, body: UpdateAnAccountParameters = ...):
    """
    Update an Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/accounts/{account_id}/close',
    tags=['account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def close_an_account(account_id: str):
    """
    Close an Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ach_prenotifications',
    tags=['ach_operations_management', 'ach_transaction_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_ach_prenotifications(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List ACH Prenotifications
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ach_prenotifications',
    tags=['ach_operations_management', 'ach_transaction_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_ach_prenotification(body: CreateAnAchPrenotificationParameters):
    """
    Create an ACH Prenotification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ach_prenotifications/{ach_prenotification_id}',
    tags=['ach_operations_management', 'ach_transaction_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_ach_prenotification(ach_prenotification_id: str):
    """
    Retrieve an ACH Prenotification
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ach_transfers',
    tags=[
        'ach_operations_management',
        'ach_transaction_handling',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_ach_transfers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    external_account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List ACH Transfers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ach_transfers',
    tags=[
        'account_transfer_operations',
        'ach_operations_management',
        'ach_transaction_handling',
        'transfer_simulation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_ach_transfer(body: CreateAnAchTransferParameters):
    """
    Create an ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/ach_transfers/{ach_transfer_id}',
    tags=[
        'account_transfer_operations',
        'ach_operations_management',
        'ach_transaction_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_ach_transfer(ach_transfer_id: str):
    """
    Retrieve an ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ach_transfers/{ach_transfer_id}/approve',
    description=""" Approves an ACH Transfer in a pending_approval state. """,
    tags=[
        'account_transfer_operations',
        'ach_operations_management',
        'ach_transaction_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def approve_an_ach_transfer(ach_transfer_id: str):
    """
    Approve an ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/ach_transfers/{ach_transfer_id}/cancel',
    description=""" Cancels an ACH Transfer in a pending_approval state. """,
    tags=[
        'account_transfer_operations',
        'ach_operations_management',
        'ach_transaction_handling',
        'pending_transaction_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_a_pending_ach_transfer(ach_transfer_id: str):
    """
    Cancel a pending ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/card_disputes',
    tags=['card_dispute_management', 'card_dispute_simulation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_card_disputes(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
    status_in: Optional[StatusIn] = Query(None, alias='status.in'),
):
    """
    List Card Disputes
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/card_disputes',
    tags=['card_dispute_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_card_dispute(body: CreateACardDisputeParameters):
    """
    Create a Card Dispute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/card_disputes/{card_dispute_id}',
    tags=['card_dispute_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_card_dispute(card_dispute_id: str):
    """
    Retrieve a Card Dispute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/card_profiles',
    tags=['card_profile_operations', 'card_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_card_profiles(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    status_in: Optional[StatusIn1] = Query(None, alias='status.in'),
):
    """
    List Card Profiles
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/card_profiles',
    tags=['card_profile_operations', 'card_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_card_profile(body: CreateACardProfileParameters):
    """
    Create a Card Profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/card_profiles/{card_profile_id}',
    tags=['card_profile_operations', 'card_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_card_profile(card_profile_id: str):
    """
    Retrieve a Card Profile
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cards',
    tags=['card_management_functions', 'card_profile_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_cards(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Cards
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/cards',
    tags=['card_management_functions', 'card_profile_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_card(body: CreateACardParameters):
    """
    Create a Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cards/{card_id}',
    tags=['card_management_functions', 'card_profile_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_card(card_id: str):
    """
    Retrieve a Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/cards/{card_id}',
    tags=['card_management_functions', 'card_profile_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_a_card(card_id: str, body: UpdateACardParameters = ...):
    """
    Update a Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/cards/{card_id}/details',
    tags=['card_management_functions', 'card_profile_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_sensitive_details_for_a_card(card_id: str):
    """
    Retrieve sensitive details for a Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/check_deposits',
    tags=['check_deposit_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_check_deposits(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Check Deposits
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/check_deposits',
    tags=['check_deposit_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_check_deposit(body: CreateACheckDepositParameters):
    """
    Create a Check Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/check_deposits/{check_deposit_id}',
    tags=['check_deposit_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_check_deposit(check_deposit_id: str):
    """
    Retrieve a Check Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/check_transfers',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_check_transfers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Check Transfers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/check_transfers',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_check_transfer(body: CreateACheckTransferParameters):
    """
    Create a Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/check_transfers/{check_transfer_id}',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_check_transfer(check_transfer_id: str):
    """
    Retrieve a Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/check_transfers/{check_transfer_id}/approve',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def approve_a_check_transfer(check_transfer_id: str):
    """
    Approve a Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/check_transfers/{check_transfer_id}/cancel',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_a_pending_check_transfer(check_transfer_id: str):
    """
    Cancel a pending Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/check_transfers/{check_transfer_id}/stop_payment',
    tags=['check_transfer_operations', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def request_a_stop_payment_on_a_check_transfer(check_transfer_id: str):
    """
    Request a stop payment on a Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/declined_transactions',
    tags=['declined_transaction_handling', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_declined_transactions(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
    route_id: Optional[str] = None,
):
    """
    List Declined Transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/declined_transactions/{declined_transaction_id}',
    tags=['declined_transaction_handling', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_declined_transaction(declined_transaction_id: str):
    """
    Retrieve a Declined Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/digital_wallet_tokens',
    tags=['digital_wallet_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_digital_wallet_tokens(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    card_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Digital Wallet Tokens
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/digital_wallet_tokens/{digital_wallet_token_id}',
    tags=['digital_wallet_token_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_digital_wallet_token(digital_wallet_token_id: str):
    """
    Retrieve a Digital Wallet Token
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents',
    tags=['document_operations_management', 'entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_documents(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    entity_id: Optional[str] = None,
    category_in: Optional[CategoryIn] = Query(None, alias='category.in'),
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Documents
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/documents/{document_id}',
    tags=['document_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_document(document_id: str):
    """
    Retrieve a Document
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/entities',
    tags=['entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_entities(cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None):
    """
    List Entities
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/entities',
    tags=['entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_entity(body: CreateAnEntityParameters):
    """
    Create an Entity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/entities/{entity_id}',
    tags=['entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_entity(entity_id: str):
    """
    Retrieve an Entity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/entities/{entity_id}/supplemental_documents',
    tags=['document_operations_management', 'entity_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_supplemental_document_for_an_entity(
    entity_id: str, body: CreateASupplementalDocumentForAnEntityParameters = ...
):
    """
    Create a supplemental document for an Entity
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event_subscriptions',
    tags=['event_subscription_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_event_subscriptions(
    cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None
):
    """
    List Event Subscriptions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/event_subscriptions',
    tags=['event_subscription_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_event_subscription(body: CreateAnEventSubscriptionParameters):
    """
    Create an Event Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/event_subscriptions/{event_subscription_id}',
    tags=['event_subscription_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_event_subscription(event_subscription_id: str):
    """
    Retrieve an Event Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/event_subscriptions/{event_subscription_id}',
    tags=['event_subscription_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_an_event_subscription(
    event_subscription_id: str, body: UpdateAnEventSubscriptionParameters = ...
):
    """
    Update an Event Subscription
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events',
    tags=['event_subscription_management_functions', 'event_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_events(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
    category_in: Optional[CategoryIn1] = Query(None, alias='category.in'),
    associated_object_id: Optional[str] = None,
):
    """
    List Events
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/events/{event_id}',
    tags=['event_management_operations', 'event_subscription_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_event(event_id: str):
    """
    Retrieve an Event
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/external_accounts',
    tags=['external_account_handling', 'account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_external_accounts(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    status_in: Optional[StatusIn2] = Query(None, alias='status.in'),
):
    """
    List External Accounts
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/external_accounts',
    tags=['external_account_handling', 'account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_external_account(body: CreateAnExternalAccountParameters):
    """
    Create an External Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/external_accounts/{external_account_id}',
    tags=['external_account_handling', 'account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_external_account(external_account_id: str):
    """
    Retrieve an External Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/external_accounts/{external_account_id}',
    tags=['account_management', 'external_account_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_an_external_account(
    external_account_id: str, body: UpdateAnExternalAccountParameters = ...
):
    """
    Update an External Account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files',
    tags=['file_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_files(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
    purpose_in: Optional[PurposeIn] = Query(None, alias='purpose.in'),
):
    """
    List Files
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/files',
    description=""" To upload a file to Increase, you'll need to send a request of Content-Type `multipart/form-data`. The request should contain the file you would like to upload, as well as the parameters for creating a file. """,
    tags=['file_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_file(file: UploadFile):
    """
    Create a File
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/files/{file_id}',
    tags=['file_operations_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_file(file_id: str):
    """
    Retrieve a File
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/groups/current',
    description=""" Returns details for the currently authenticated Group. """,
    tags=[
        'account_management',
        'event_management_operations',
        'entity_operations_management',
        'transaction_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_group_details():
    """
    Retrieve Group details
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inbound_ach_transfer_returns',
    tags=[
        'ach_operations_management',
        'ach_transaction_handling',
        'transaction_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_inbound_ach_transfer_returns(
    cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None
):
    """
    List Inbound ACH Transfer Returns
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/inbound_ach_transfer_returns',
    tags=['ach_operations_management', 'ach_transaction_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_an_ach_return(body: CreateAnAchReturnParameters):
    """
    Create an ACH Return
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inbound_ach_transfer_returns/{inbound_ach_transfer_return_id}',
    tags=[
        'ach_operations_management',
        'ach_transaction_handling',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_inbound_ach_transfer_return(inbound_ach_transfer_return_id: str):
    """
    Retrieve an Inbound ACH Transfer Return
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inbound_wire_drawdown_requests',
    tags=['transaction_management_functions', 'wire_drawdown_request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_inbound_wire_drawdown_requests(
    cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None
):
    """
    List Inbound Wire Drawdown Requests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/inbound_wire_drawdown_requests/{inbound_wire_drawdown_request_id}',
    tags=['transaction_management_functions', 'wire_drawdown_request_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_inbound_wire_drawdown_request(inbound_wire_drawdown_request_id: str):
    """
    Retrieve an Inbound Wire Drawdown Request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/limits',
    tags=['limit_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_limits(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    model_id: Optional[constr(min_length=1, max_length=200)] = None,
    status: Optional[constr(min_length=1, max_length=200)] = None,
):
    """
    List Limits
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/limits',
    tags=['limit_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_limit(body: CreateALimitParameters):
    """
    Create a Limit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/limits/{limit_id}',
    tags=['limit_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_limit(limit_id: str):
    """
    Retrieve a Limit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.patch(
    '/limits/{limit_id}',
    tags=['limit_management_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def update_a_limit(limit_id: str, body: UpdateALimitParameters = ...):
    """
    Update a Limit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/oauth_connections',
    tags=['oauth_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_oauth_connections(
    cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None
):
    """
    List OAuth Connections
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/oauth_connections/{oauth_connection_id}',
    tags=['oauth_connection_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_an_oauth_connection(oauth_connection_id: str):
    """
    Retrieve an OAuth Connection
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pending_transactions',
    tags=['pending_transaction_handling', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_pending_transactions(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    route_id: Optional[str] = None,
    source_id: Optional[str] = None,
    status_in: Optional[StatusIn3] = Query(None, alias='status.in'),
):
    """
    List Pending Transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/pending_transactions/{pending_transaction_id}',
    tags=['pending_transaction_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_pending_transaction(pending_transaction_id: str):
    """
    Retrieve a Pending Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/real_time_decisions/{real_time_decision_id}',
    tags=['real_time_decision_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_real_time_decision(real_time_decision_id: str):
    """
    Retrieve a Real-Time Decision
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/real_time_decisions/{real_time_decision_id}/action',
    tags=['real_time_decision_handling'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def action_a_real_time_decision(
    real_time_decision_id: str, body: ActionARealTimeDecisionParameters = ...
):
    """
    Action a Real-Time Decision
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/routing_numbers',
    description=""" You can use this API to confirm if a routing number is valid, such as when a user is providing you with bank account details. Since routing numbers uniquely identify a bank, this will always return 0 or 1 entry. In Sandbox, the only valid routing number for this method is 110000000. """,
    tags=['routing_number_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_routing_numbers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    routing_number: constr(min_length=9, max_length=9) = ...,
):
    """
    List Routing Numbers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/account_statements',
    description=""" Simulates an [Account Statement](#account-statements) being created for an account. In production, Account Statements are generated once per month. """,
    tags=['account_statements_handling', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_an_account_statement_being_created(
    body: SimulateAnAccountStatementBeingCreatedParameters,
):
    """
    Simulate an Account Statement being created
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/account_transfers/{account_transfer_id}/complete',
    description=""" If your account is configured to require approval for each transfer, this endpoint simulates the approval of an [Account Transfer](#account-transfers). You can also approve sandbox Account Transfers in the dashboard. This transfer must first have a `status` of `pending_approval`. """,
    tags=['account_transfer_operations', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def complete_a_sandbox_account_transfer(account_transfer_id: str):
    """
    Complete a Sandbox Account Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/ach_transfers/{ach_transfer_id}/return',
    description=""" Simulates the return of an [ACH Transfer](#ach-transfers) by the Federal Reserve due to an error condition. This will also create a Transaction to account for the returned funds. This transfer must first have a `status` of `submitted`. """,
    tags=[
        'ach_operations_management',
        'ach_transaction_handling',
        'sandbox_transaction_simulation',
        'transfer_simulation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def return_a_sandbox_ach_transfer(
    ach_transfer_id: str, body: ReturnASandboxAchTransferParameters = ...
):
    """
    Return a Sandbox ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/ach_transfers/{ach_transfer_id}/submit',
    description=""" Simulates the submission of an [ACH Transfer](#ach-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_submission`. In production, Increase submits ACH Transfers to the Federal Reserve three times per day on weekdays. Since sandbox ACH Transfers are not submitted to the Federal Reserve, this endpoint allows you to skip that delay and transition the ACH Transfer to a status of `submitted`. """,
    tags=[
        'ach_operations_management',
        'ach_transaction_handling',
        'sandbox_transaction_simulation',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_a_sandbox_ach_transfer(ach_transfer_id: str):
    """
    Submit a Sandbox ACH Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/card_authorizations',
    description=""" Simulates a purchase authorization on a [Card](#cards). Depending on the balance available to the card and the `amount` submitted, the authorization activity will result in a [Pending Transaction](#pending-transactions) of type `card_authorization` or a [Declined Transaction](#declined-transactions) of type `card_decline`. You can pass either a Card id or a [Digital Wallet Token](#digital-wallet-tokens) id to simulate the two different ways purchases can be made. """,
    tags=['card_transaction_simulation_management', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_an_authorization_on_a_card(body: SimulateAnAuthorizationOnACardParameters):
    """
    Simulate an authorization on a Card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/card_disputes/{card_dispute_id}/action',
    description=""" After a [Card Dispute](#card-disputes) is created in production, the dispute will be reviewed. Since no review happens in sandbox, this endpoint simulates moving a Card Dispute into a rejected or accepted state. A Card Dispute can only be actioned one time and must have a status of `pending_reviewing`. """,
    tags=['card_dispute_management', 'card_dispute_simulation_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulates_advancing_the_state_of_a_card_dispute(
    card_dispute_id: str, body: SimulatesAdvancingTheStateOfACardDisputeParameters = ...
):
    """
    Simulates advancing the state of a card dispute
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/card_refunds',
    description=""" Simulates refunding a card transaction. The full value of the original sandbox transaction is refunded. """,
    tags=['card_transaction_simulation_management', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_a_refund_on_a_card(body: SimulateARefundOnACardParameters):
    """
    Simulate a refund on a card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/card_settlements',
    description=""" Simulates the settlement of an authorization by a card acquirer. After a card authorization is created, the merchant will eventually send a settlement. This simulates that event, which may occur many days after the purchase in production. The amount settled can be different from the amount originally authorized, for example, when adding a tip to a restaurant bill. """,
    tags=['card_transaction_simulation_management', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_settling_a_card_authorization(
    body: SimulateSettlingACardAuthorizationParameters,
):
    """
    Simulate settling a card authorization
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/check_deposits/{check_deposit_id}/reject',
    description=""" Simulates the rejection of a [Check Deposit](#check-deposits) by Increase due to factors like poor image quality. This Check Deposit must first have a `status` of `pending`. """,
    tags=['check_deposit_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def reject_a_sandbox_check_deposit(check_deposit_id: str):
    """
    Reject a Sandbox Check Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/check_deposits/{check_deposit_id}/return',
    description=""" Simulates the return of a [Check Deposit](#check-deposits). This Check Deposit must first have a `status` of `submitted`. """,
    tags=['check_deposit_operations', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def return_a_sandbox_check_deposit(check_deposit_id: str):
    """
    Return a Sandbox Check Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/check_deposits/{check_deposit_id}/submit',
    description=""" Simulates the submission of a [Check Deposit](#check-deposits) to the Federal Reserve. This Check Deposit must first have a `status` of `pending`. """,
    tags=['check_deposit_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_a_sandbox_check_deposit(check_deposit_id: str):
    """
    Submit a Sandbox Check Deposit
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/check_transfers/{check_transfer_id}/deposit',
    description=""" Simulates a [Check Transfer](#check-transfers) being deposited at a bank. This transfer must first have a `status` of `mailed`. """,
    tags=['check_deposit_operations', 'check_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def deposit_a_sandbox_check_transfer(check_transfer_id: str):
    """
    Deposit a Sandbox Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/check_transfers/{check_transfer_id}/mail',
    description=""" Simulates the mailing of a [Check Transfer](#check-transfers), which happens once per weekday in production but can be sped up in sandbox. This transfer must first have a `status` of `pending_approval` or `pending_submission`. """,
    tags=['check_transfer_operations', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def mail_a_sandbox_check_transfer(check_transfer_id: str):
    """
    Mail a Sandbox Check Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/digital_wallet_token_requests',
    description=""" Simulates a user attempting add a [Card](#cards) to a digital wallet such as Apple Pay. """,
    tags=['digital_wallet_token_management', 'card_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_digital_wallet_provisioning_for_a_card(
    body: SimulateDigitalWalletProvisioningForACardParameters,
):
    """
    Simulate digital wallet provisioning for a card
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/documents',
    description=""" Simulates an tax document being created for an account. """,
    tags=['document_operations_management', 'sandbox_transaction_simulation'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_a_tax_document_being_created(
    body: SimulateATaxDocumentBeingCreatedParameters,
):
    """
    Simulate a tax document being created
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/inbound_ach_transfers',
    description=""" Simulates an inbound ACH transfer to your account. This imitates initiating a transaction to an Increase account from a different financial institution. The transfer may be either a credit or a debit depending on if the `amount` is positive or negative. The result of calling this API will be either a [Transaction](#transactions) or a [Declined Transaction](#declined-transactions) depending on whether or not the transfer is allowed. """,
    tags=['ach_operations_management', 'transfer_simulation_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_an_ach_transfer_to_your_account(
    body: SimulateAnAchTransferToYourAccountParameters,
):
    """
    Simulate an ACH Transfer to your account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/inbound_real_time_payments_transfers',
    description=""" Simulates an inbound Real Time Payments transfer to your account. Real Time Payments are a beta feature. """,
    tags=['account_transfer_operations', 'transfer_simulation_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_a_real_time_payments_transfer_to_your_account(
    body: SimulateARealTimePaymentsTransferToYourAccountParameters,
):
    """
    Simulate a Real Time Payments Transfer to your account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/inbound_wire_drawdown_requests',
    description=""" Simulates the receival of an [Inbound Wire Drawdown Request](#inbound-wire-drawdown-requests). """,
    tags=[
        'wire_drawdown_request_management',
        'transfer_simulation_operations',
        'transaction_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_an_inbound_wire_drawdown_request_being_created(
    body: SimulateAnInboundWireDrawdownRequestBeingCreatedParameters,
):
    """
    Simulate an Inbound Wire Drawdown request being created
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/inbound_wire_transfers',
    description=""" Simulates an inbound Wire Transfer to your account. """,
    tags=[
        'wire_transfer_management_functions',
        'transfer_simulation_operations',
        'sandbox_transaction_simulation',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def simulate_a_wire_transfer_to_your_account(
    body: SimulateAWireTransferToYourAccountParameters,
):
    """
    Simulate a Wire Transfer to your account
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/wire_transfers/{wire_transfer_id}/reverse',
    description=""" Simulates the reversal of a [Wire Transfer](#wire-transfers) by the Federal Reserve due to error conditions. This will also create a [Transaction](#transaction) to account for the returned funds. This Wire Transfer must first have a `status` of `complete`.' """,
    tags=[
        'wire_transfer_management_functions',
        'account_transfer_operations',
        'transfer_simulation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def reverse_a_sandbox_wire_transfer(wire_transfer_id: str):
    """
    Reverse a Sandbox Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/simulations/wire_transfers/{wire_transfer_id}/submit',
    description=""" Simulates the submission of a [Wire Transfer](#wire-transfers) to the Federal Reserve. This transfer must first have a `status` of `pending_approval` or `pending_creating`. """,
    tags=[
        'wire_transfer_management_functions',
        'sandbox_transaction_simulation',
        'transfer_simulation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def submit_a_sandbox_wire_transfer(wire_transfer_id: str):
    """
    Submit a Sandbox Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions',
    tags=[
        'transaction_management_functions',
        'ach_transaction_handling',
        'pending_transaction_handling',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_transactions(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
    category_in: Optional[CategoryIn2] = Query(None, alias='category.in'),
    route_id: Optional[str] = None,
):
    """
    List Transactions
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/transactions/{transaction_id}',
    tags=['transaction_management_functions', 'account_management'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_transaction(transaction_id: str):
    """
    Retrieve a Transaction
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wire_drawdown_requests',
    tags=['wire_drawdown_request_management', 'transaction_management_functions'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_wire_drawdown_requests(
    cursor: Optional[str] = None, limit: Optional[conint(ge=0)] = None
):
    """
    List Wire Drawdown Requests
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wire_drawdown_requests',
    tags=[
        'wire_drawdown_request_management',
        'transaction_management_functions',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_wire_drawdown_request(body: CreateAWireDrawdownRequestParameters):
    """
    Create a Wire Drawdown Request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wire_drawdown_requests/{wire_drawdown_request_id}',
    tags=[
        'wire_drawdown_request_management',
        'transaction_management_functions',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_wire_drawdown_request(wire_drawdown_request_id: str):
    """
    Retrieve a Wire Drawdown Request
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wire_transfers',
    tags=[
        'wire_transfer_management_functions',
        'transaction_management_functions',
        'account_transfer_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def list_wire_transfers(
    cursor: Optional[str] = None,
    limit: Optional[conint(ge=0)] = None,
    account_id: Optional[str] = None,
    external_account_id: Optional[str] = None,
    created_at_after: Optional[datetime] = Query(None, alias='created_at.after'),
    created_at_before: Optional[datetime] = Query(None, alias='created_at.before'),
    created_at_on_or_after: Optional[datetime] = Query(
        None, alias='created_at.on_or_after'
    ),
    created_at_on_or_before: Optional[datetime] = Query(
        None, alias='created_at.on_or_before'
    ),
):
    """
    List Wire Transfers
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wire_transfers',
    tags=[
        'account_transfer_operations',
        'wire_transfer_management_functions',
        'transfer_simulation_operations',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def create_a_wire_transfer(body: CreateAWireTransferParameters):
    """
    Create a Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.get(
    '/wire_transfers/{wire_transfer_id}',
    tags=[
        'wire_transfer_management_functions',
        'account_transfer_operations',
        'transaction_management_functions',
    ],
    security=[
        HTTPBearer(name="None"),
    ],
)
def retrieve_a_wire_transfer(wire_transfer_id: str):
    """
    Retrieve a Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wire_transfers/{wire_transfer_id}/approve',
    tags=['wire_transfer_management_functions', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def approve_a_wire_transfer(wire_transfer_id: str):
    """
    Approve a Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


@app.post(
    '/wire_transfers/{wire_transfer_id}/cancel',
    tags=['wire_transfer_management_functions', 'account_transfer_operations'],
    security=[
        HTTPBearer(name="None"),
    ],
)
def cancel_a_pending_wire_transfer(wire_transfer_id: str):
    """
    Cancel a pending Wire Transfer
    """
    raise RuntimeError("Should be patched by MCPProxy and never executed")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description="MCP Server")
    parser.add_argument(
        "transport",
        choices=["stdio", "sse", "streamable-http"],
        help="Transport mode (stdio, sse or streamable-http)",
    )
    args = parser.parse_args()

    if "CONFIG_PATH" in os.environ:
        config_path = os.environ["CONFIG_PATH"]
        app.load_configuration(config_path)

    if "CONFIG" in os.environ:
        config = os.environ["CONFIG"]
        app.load_configuration_from_string(config)

    if "SECURITY" in os.environ:
        security_params = BaseSecurity.parse_security_parameters_from_env(
            os.environ,
        )

        app.set_security_params(security_params)

    mcp_settings = json.loads(os.environ.get("MCP_SETTINGS", "{}"))

    app.get_mcp(**mcp_settings).run(transport=args.transport)
